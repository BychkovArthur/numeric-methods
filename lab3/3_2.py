import numpy as np
from copy import copy

'''
    Вариант №2
    
    Интерполяционный многочлен может колебаться между точками. Для избавления от этого недостатка используют сплайн интерполяцию
    Суть сплайн-интерполяции заключается в определении интерполирющей функции по формулам одного 
    типа для различных непересекающихся промежутков и в стыковке значений функции
    и ее производных на их границах.
    
    Сплайн - многочлен n-й степени, который в узлах интерполяции принимает значения аппрокимируемой функции и непрерывен вместе со своими (n-1) производными.

    S(x) = a_i + b_i(x - x_{i-1}) + c_i(x-x_{i-1})^2 + d_i(x-x{i-1})^3
    x_{i-1}<=x<=x_i; i=1,...,n
    
    Нужно построить n многочленой третьей степени, т.е. определить 4n неизвестных ai, bi, ci, di
    
    S_1(x) = a_1 + b_1(x - x_0) + c_1(x - x_0)^2 + d_1(x - x_0)^3
    ...
    S_n(x) = a_n + b_n(x - x_{n-1}) + c_n(x - x_{n-1}) + d_n(x - x_{n-1})^3
    
    --------------
    Теперь, из условий в узлах сетки можно записать:
                    Справа от точки                Слева от точки
                   (x_{i-1} <= x <= x_i)  (x_{i-2} <= x <= x_{i-1})
    S(x_{i - 1}) =           a_i        = a_{i-1} + b_{i-1}(x_{i-1} - x_{i-2}) + c_{i-1}(x_{i-1} - x_{i-2})^2 + d_{i-1}(x_{i-1} - x_{i-2})^3 = f_{i_1}
   S'(x_{i - 1}) =           b_i        = b_{i-1} + 2*c_{i-1}(x_{i-1} - x_{i-2}) + 3*d_{i-1}(x_{i-1} - x_{i-2})^2
  S''(x_{i - 1}) =         2*c_i        = 2*c_i + 6*d_{i-1}(x_{i-1} - x_{i-2})
    
    i = 2, ..., n
    
    S(x_0)       =           a_1        = f0
  S''(x_0)       =          2c_1        = 0   (нулевая кривизна)
    
    S(x_n)       =                      = a_n + b_n(x_n - x_{n-1}) + c_n(x_n - x_{n-1})^2 + d_n(x_n - x_{n-1})^3 = f_n
  S''(x_n)       =                      = 2*c_n + 6*d_n(x_n - x_{n-1}) = 0 (нулевая кривизна)
    
    
    
    
    
    В нашей задаче сплайн имеет нулевую кривизну в точках x_0 и x_n
    
    S(x_0) = a_1
'''

def tridiagonalMatrixAlgorithm(A, b):
    '''
        Функция из 1.2
    '''
    n = len(b)

    # Вычисляем прогоночные коэффициенты
    P = np.empty((n))
    P[0] = -A[0][2] / A[0][1]
    Q = np.empty((n))
    Q[0] = b[0] / A[0][1]
    for i in range(n):
        P[i] = (-A[i][2]) / (A[i][1] + A[i][0] * P[i - 1])
        Q[i] = (b[i] - A[i][0] * Q[i - 1]) / (A[i][1] + A[i][0] * P[i - 1])

    # Обратный ход
    x = np.empty((n))
    x[n - 1] = Q[n - 1]
    for i in range(n - 2, -1, -1):
        x[i] = P[i] * x[i + 1] + Q[i]

    return x


def spline(xs, fs: list, x):
    n = len(xs)
    hs = [0] + [xs[i] - xs[i - 1] for i in range(1, n)]  # Считаем h_i = x_i - x_{i-1}
    A = np.zeros((n - 2, 3))

    # Первая строка
    A[0][0] = 2 * (hs[1] + hs[2])
    A[0][1] = hs[2]
    A[0][2] = 0

    # Последняя строка
    A[n - 3][0] = 0
    A[n - 3][1] = hs[n - 2]
    A[n - 3][2] = 2 * (hs[n - 2] + hs[n - 1])

    # Остальные строки
    for i in range(3, n - 1):
        A[i - 2][0] = hs[i - 1]
        A[i - 2][1] = 2 * (hs[i - 1] + hs[i])
        A[i - 2][2] = hs[i]

    b = np.zeros(n - 2)
    for i in range(n - 2):
        b[i] = 3 * ((fs[i + 2] - fs[i + 1]) / (hs[i + 2]) - (fs[i + 1] - fs[i]) / (hs[i + 1]))

    """
        Нашли c, теперь восстанавливаем a, b, d
    """

    cs = tridiagonalMatrixAlgorithm(A, b)
    cs = np.concatenate((np.zeros(1), cs))  # Добавляем c_0 = 0

    as_ = copy(fs)                          # a_i = f_{i-1}
    as_.pop()
    as_ = np.array(as_)

    bs = np.zeros(n - 1)
    for i in range(n - 2):
        bs[i] = (fs[i + 1] - fs[i]) / hs[i + 1] - 1/3 * hs[i + 1] * (cs[i + 1] + 2 * cs[i])
    bs[n - 2] = (fs[n - 1] - fs[n - 2]) / hs[n - 1] - 2/3 * hs[n - 1] * cs[n - 2]

    ds = np.zeros(n - 1)
    for i in range(n - 2):
        ds[i] = (cs[i + 1] - cs[i]) / (3 * hs[i + 1])
    ds[n - 2] = - cs[n - 2] / (3 * hs[n - 1])

    res = 0
    for i in range(n - 1):
        # Находим нужный сплайн
        if xs[i] <= x and x <= xs[i + 1]:
            res = as_[i] + bs[i] * (x - xs[i]) + cs[i] * (x - xs[i])**2 + ds[i] * (x - xs[i])**3

    return res

xs = [0, 1.0, 2.0, 3.0, 4.0]
fs = [1.0, 0.86603, 0.5, 0.0, -0.5]
x = 1.5

y = spline(xs, fs, x)
print(f"Значение в {x}: ", y)